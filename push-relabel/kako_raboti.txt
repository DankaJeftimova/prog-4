Како работи алгоритмот:


Push relabel е алгроитам што наоѓа max flow од теме s до теме t.

Користи вишок flow. Сите темиња освен почетното и крајното може да имаат вишок на проток на одредено
време, т.е проток поголем од капацитетот на реброто до и од тоа теме.

Секое теме има висина, а на протокот му е дозволено да се движи само надоле. Ова спречува бескрајни 
циклуси (loop). На почеток висината на почетното теме е бројот на темиња. Висината на сите други
темиња е 0 на почеток.

Ако едно ребро има доволно капацитет и висината на темињата одговара правиме push. Ако ова резултира
со тоа дека некое теме ќе има позитивен вишок, тогаш тоа теме станува активно и треба да го
процисираме потоа.

Ако теме има вишок но не може да push на друго теме бидејќи висините не одговараат тогаш висината на
тоа теме ќе ја зголемиме на минималната висина која ќе му дозволи на тоа теме да направи push. Ова е
relabel.

Ги пробуваме сите соседи на некое теме за да видиме дали може да направиме push, ако не може на никое
поради висините тогаш правиме relabel. Оваа постапка ја правиме се додека вишокот не стане 0.

На крајот протокот што ќе оди во крајното теме е максимален.




Како работи кодот:


Корисникот ја има опцијата да избере дали сака кодот да биде извршен на случаен граф или на граф кој
што тој ќе го внесе. 

capacity[u][v] → максимален капацитет на раб (u,v)

flow[u][v] → тековен проток

height[u] → висина

excess[u] → вишок проток

seen[u] → индекс кој кажува кои соседи сме ги гледале

excess_vertices → јазли кои имаат вишок проток


Функцијата push турка онолку проток колку што е можно од u во v, додека relabel
го зголемува нивото на јазолот кога не може да турка проток кон ниту еден сосед. Функцијата discharge(u)
го обработува јазолот сè додека има вишок, обидувајќи се да го нападне секој сосед или, ако тоа не
е можно, го релабелира. Функцијата make_graph(n) генерира случаен граф. Главната функција
max_flow го иницијализира алгоритмот така што го поставува изворниот јазол на највисока висина,
го полни со голем вишок и ги pre flow сите излезни рабови од него. Потоа обработува јазли со вишок
додека excess_vertices не се испразни, а на крајот ја сумира количината проток што стигнува до целниот
јазол.
Во main() се користи srand(time(0)) за да се добие различна случајна генерација секојпат. Корисникот 
може да избере дали да користи случаен граф или сам да внесе податоци, програмот потоа ги пополнува
капацитетите, го извршува алгоритмот и го печати максималниот проток од јазол 0 до n−1.



Прво иницијализираме preflow така што сите рабови кои излаваат од почетното теме ќе имаат flow што е
е еднаква на капацитетот и excess flow минус камацитет. Вишок од крајното е 0. Темињата поврзани со
почетното ќе станат активни бидејќи ќе имаат позитивен вишок. Т.е ги додаваме во редот и ги
обработуваме потоа. 


Земаме едно активно теме и гледаме со кои од неговите соседи важи условот за висината, ако за ниедно
не важи ја менуваме висината на тоа поле. Потоа пробуваме да турнеме вишок од тоа теме кон соседите
соодветно менуваме вишок и проток по оваа формулаЧ
    flow[u][v] += d;
    flow[v][u] -= d;
    excess[u] -= d; 
    excess[v] += d;


Оваа постапка ја повторуваме се додека вишокот на сите темиња освен почетното и крајното не е 0.
Потоа пресметуваме max flow.